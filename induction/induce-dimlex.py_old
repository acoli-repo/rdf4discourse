import sys,os,re,argparse,gzip

args=argparse.ArgumentParser(description="perform discourse marker induction, note that we calculate the symmetric closure of all dictionaries\nNote on evaluation: depth 0: True if discourse marker, depth 1: PDTB top-level, depth 2: (up to) PDTB second-level, dept 3: (up to) PDTB full\nNote that we assume completeness, so elements not found in a dimlex are assumed not to be discourse markers")

# todo: different methods
args.add_argument("--dimlex", type=str, action="extend", nargs="+", help="dimlex files, TSV format (uncompressed), must contain language codes as second column; column structure  word lang pdtb1 pdtb2 pdtb3", required=True)
args.add_argument("--dict", type=str, action="extend", nargs="+", help="bilingual dictionaries, TIAD-TSV format or gzipped TIAD-TSV format, must contain language codes", required=True)
args.add_argument("--tgt", type=str, action="extend", nargs="+", help="target language(s), if these are among DIMLEX arguments, exclude these from training and evaluate against the DIMLEXes",required=True)

args=args.parse_args()

lang2marker2depth2rels={}

for d in args.dimlex:
	sys.stderr.write("adding dimlex "+d+"\n")
	with open(d,"r") as input:
		for line in input:
			if(not line.startswith("#")):
				line=re.sub(r"(^\\)#.","$1",line)
				line=line.rstrip()
				fields=line.split("\t")
				if(len(fields)>4):
					word=fields[0]
					lang=fields[1]
					pdtb1=fields[2]
					pdtb2=fields[3]
					pdtb3=fields[4]
					if(not lang in lang2marker2depth2rels):
						lang2marker2depth2rels[lang]={ word: [ set([True]), set([pdtb1]), set([pdtb2]), set([pdtb3]) ] }
					elif(not word in lang2marker2depth2rels[lang]):
						lang2marker2depth2rels[lang][word] = [ set([True]), set([pdtb1]), set([pdtb2]), set([pdtb3]) ]
					else:
						lang2marker2depth2rels[lang][word][1].add(pdtb1)
						lang2marker2depth2rels[lang][word][2].add(pdtb2)
						lang2marker2depth2rels[lang][word][3].add(pdtb3)
					for l in lang2marker2depth2rels:
						sys.stderr.write(" "+l+": "+str(len(lang2marker2depth2rels[l])))
					sys.stderr.write("\r")
					sys.stderr.flush()
	sys.stderr.write("\n")

lang2src2lang2tgts={}

for d in args.dict:
	sys.stderr.write("adding dict "+d+"\n")
	input=None
	# try:
	if True:
		if d.endswith("gz") or d.endswith("gzip"):
			input=gzip.open(d,"r")
		else:
			input=open(d,"r")
		for line in input:
			if(type(line)==bytes):
				line=line.decode("utf-8")
			if(not line.startswith("#")):
				line=re.sub(r"(^\\)#.","$1",line)
				line=line.rstrip()
				fields=line.split("\t")
				if(len(fields)>4):
					src=fields[0]
					slang=""
					if("@" in src):
						slang=re.sub(r".*@","",src)
					src=re.sub("@.*","",src)
					src=re.sub(r"^[']+(.*)[']+$",r"\1",src)
					src=re.sub(r"^[\"]+(.*)[\"]+$",r"\1",src)
					
					tgt=fields[-1]					
					tlang=""
					if("@" in tgt):
						tlang=re.sub(r".*@","",tgt)
					tgt=re.sub("@.*","",tgt)
					tgt=re.sub(r"^[']+(.*)[']+$",r"\1",tgt)
					tgt=re.sub(r"^[\"]+(.*)[\"]+$",r"\1",tgt)
					
					if(not re.match(r"^[a-z][a-z][a-z]?$",slang)):
						sys.stderr.write("  warning: invalid source language \""+slang+"\"\n")
					elif(not re.match(r"^[a-z][a-z][a-z]?$",tlang)):
						sys.stderr.write("  warning: invalid target language \""+tlang+"\"\n")
					else: # valid language tag
						for src, slang, tgt, tlang in [ (src, slang, tgt, tlang) , (tgt, tlang, src, slang)] :
							if(not slang in lang2src2lang2tgts):
								lang2src2lang2tgts[slang]= { src : { tlang : set([tgt]) } }
							elif(not src in lang2src2lang2tgts[slang]):
								lang2src2lang2tgts[slang][src] = { tlang : set([tgt]) }
							elif(not tlang in lang2src2lang2tgts[slang][src]):
								lang2src2lang2tgts[slang][src][tlang] = set([tgt])
							else:
								lang2src2lang2tgts[slang][src][tlang].add(tgt)
						for l in lang2src2lang2tgts:
							sys.stderr.write(" "+l+":"+str(len(lang2src2lang2tgts[l])))
						sys.stderr.write("\r")
						sys.stderr.flush()
		input.close()
	# except :
		# pass
	sys.stderr.write("\n")

for tlang in args.tgt:
	if not tlang in lang2src2lang2tgts:
		sys.stderr.write("error: target language \""+tlang+"\" not in dictionaries, skipping\n")
		sys.stderr.flush()
	else:
		sys.stderr.write("initialize induction for \""+tlang+"\"\n");
		lang2marker2depth2rel2score={}
		classified=0
		for slang in lang2marker2depth2rels:
			if(not slang in lang2src2lang2tgts):
				sys.stderr.write("warning: excluding source language \""+slang+"\": no source DICT found\n")
			else:
				if slang!=tlang:
					if not slang in lang2marker2depth2rel2score:
						lang2marker2depth2rel2score[slang] = { slang: {} }
					for marker in lang2marker2depth2rels[slang]:
						if not marker in lang2marker2depth2rel2score[slang]:
							lang2marker2depth2rel2score[slang][marker] = {}
						for depth in range(len(lang2marker2depth2rels[slang][marker])):
							if not depth in lang2marker2depth2rel2score[slang][marker]:
								lang2marker2depth2rel2score[slang][marker][depth]={}
							for rel in lang2marker2depth2rels[slang][marker][depth]:
								lang2marker2depth2rel2score[slang][marker][depth][rel]=1.0/float(len(lang2marker2depth2rels[slang][marker][depth]))
							classified+=1
							sys.stderr.write(" "+str(classified)+" forms\r")
							sys.stderr.flush()
					for word in lang2src2lang2tgts[slang]:
						if not word in lang2marker2depth2rel2score[slang]:
							lang2marker2depth2rel2score[slang][word] = { 0: {True : 0.0}, 1: {}, 2:{}, 3:{}}
							classified+=1
							sys.stderr.write(" "+str(classified)+" forms\r")
							sys.stderr.flush()
		sys.stderr.write("\n")
		
		sys.stderr.write("induce\r")
		additions=-1
		while(additions!=0):
			if(additions>0):
				classified=classified+additions
			additions=0
			for lang in lang2src2lang2tgts:
				if(lang == tlang or not lang in lang2marker2depth2rels):
					#print(lang)
					for word in lang2src2lang2tgts[lang]:
						if(not lang in lang2marker2depth2rel2score or 
							not word in lang2marker2depth2rel2score[lang]):
							mytlangs = sorted(set(lang2src2lang2tgts[lang][word].keys()) & set(lang2marker2depth2rel2score.keys()))
							if(len(mytlangs)>0):
								tgts=0
								for mytlang in mytlangs:
									#print(word,lang,"via",mytlang)
									for tgt in lang2src2lang2tgts[lang][word][mytlang]:
										if(tgt in lang2marker2depth2rel2score[mytlang]):
											found=True
											tgts+=1
											for depth in lang2marker2depth2rel2score[mytlang][tgt]:
												for rel in lang2marker2depth2rel2score[mytlang][tgt][depth]:
													if(not lang in lang2marker2depth2rel2score):
														lang2marker2depth2rel2score[lang]={}
													if(not word in lang2marker2depth2rel2score[lang]):
														lang2marker2depth2rel2score[lang][word]={}
													if(not depth in lang2marker2depth2rel2score[lang][word]):
														lang2marker2depth2rel2score[lang][word][depth]={}
													if(not rel in lang2marker2depth2rel2score[lang][word][depth]):
														lang2marker2depth2rel2score[lang][word][depth][rel]=0.0
													lang2marker2depth2rel2score[lang][word][depth][rel]+=lang2marker2depth2rel2score[mytlang][tgt][depth][rel]
													#print(lang,word,depth,rel,lang2marker2depth2rel2score[lang][word][depth][rel])
								if tgts>0:
									if(word in lang2marker2depth2rel2score[lang]):
										for depth in lang2marker2depth2rel2score[lang][word]:
											for rel in lang2marker2depth2rel2score[lang][word][depth]:
												lang2marker2depth2rel2score[lang][word][depth][rel]=lang2marker2depth2rel2score[lang][word][depth][rel]/float(tgts)
										#print(lang,word)
										additions+=1
										sys.stderr.write("induce: "+str(classified+additions)+"\r")
										sys.stderr.flush()
			sys.stderr.write("\n")
			
		sys.stderr.write("\n")
		sys.stderr.flush()

		
		print("induce\nfrom",end=" ")
		for slang in lang2marker2depth2rels:
			if not slang==tlang:
				print(slang,end=" ")
		print("\nvia "," ".join(args.dict))
		print("to",tlang)
				
		thresholds=[]
		tp=[]
		fn=[]
		fp=[]		
		
		steps=10
		for threshold in range(steps+1):
			thresholds.append(float(threshold)/float(steps))
			tp.append([0,0,0,0])
			fn.append([0,0,0,0])			
			fp.append([0,0,0,0])
		# note that we count individual *senses*
		
		if(tlang in lang2marker2depth2rel2score):
			for marker in sorted(lang2marker2depth2rel2score[tlang]):
				for p,t in enumerate(thresholds):
					if(lang2marker2depth2rel2score[tlang][marker][0][True]<=t):
						if(marker in lang2marker2depth2rels[tlang]): # fn
							for depth in range(4):
								fn[p][depth]+=len(lang2marker2depth2rels[tlang][marker][depth])
					else: # predict as discourse marker, then check every line individually
						for depth in range(4):
							if(depth in lang2marker2depth2rel2score[tlang][marker]):
								for rel in lang2marker2depth2rel2score[tlang][marker][depth]:
									if not marker in lang2marker2depth2rels[tlang] or not rel in lang2marker2depth2rels[tlang][marker][depth]:
										fp[p][depth]+=1
									else:
										tp[p][depth]+=1
				if lang2marker2depth2rel2score[tlang][marker][0][True]>0.0:
					for depth in sorted(lang2marker2depth2rel2score[tlang][marker]):
						for rel in sorted(lang2marker2depth2rel2score[tlang][marker][depth]):
							print(marker+"\t"+str(depth)+"\t"+str(rel)+"\t"+str(lang2marker2depth2rel2score[tlang][marker][depth][rel]))
					print()

		print("no OOV")
		print("======\n")
		for depth in range(4):
			print("threshold","depth","tp","fp","fn", "p","r","f")
			for t in range(len(thresholds)):
				p = float(tp[t][depth]+fp[t][depth])
				r = float(tp[t][depth]+fn[t][depth])
				if p>0.0:
					p = tp[t][depth]/p
				if r >0.0:
					r =tp[t][depth]/r
				f=0.0
				if(r+p>0):
					f=2.0*p*r/float(r+p)
				print(thresholds[t],depth,tp[t][depth],fp[t][depth], fn[t][depth], 
					p,r,f)
			print()

		print()
		print("with OOV")
		print("======\n")
		for marker in lang2marker2depth2rels[tlang]:
			if not marker in lang2marker2depth2rel2score[tlang]:
				for depth in range(4):
					for t in range(len(thresholds)):
						fn[t][depth]+=1
		
		for depth in range(4):
			print("threshold","depth","tp","fp","fn", "p","r","f")
			for t in range(len(thresholds)):
				p = float(tp[t][depth]+fp[t][depth])
				r = float(tp[t][depth]+fn[t][depth])
				if p>0.0:
					p = tp[t][depth]/p
				if r >0.0:
					r =tp[t][depth]/r
				f=0.0
				if(r+p>0):
					f=2.0*p*r/float(r+p)
				print(thresholds[t],depth,tp[t][depth],fp[t][depth], fn[t][depth], 
					p,r,f)
			print()
